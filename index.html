<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Crusher Animation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #1a1a1a;
            font-family: Arial, sans-serif;
        }
        canvas {
            width: 100%;
            height: 100vh;
        }
        #crushBtn {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            font-size: 16px;
            background: #FF4136;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 1000;
            transition: background-color 0.3s;
        }
        #crushBtn:hover {
            background: #E7261D;
        }
        #activeWord {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #FFD700;
            font-size: 48px;
            font-weight: bold;
            z-index: 1000;
            display: flex;
            gap: 2px;
            transition: all 0.3s ease-in-out;
        }
        .letter {
            transition: all 0.3s ease-in-out;
        }
        .crushed {
            transform: scaleX(0.4);
        }
        .crushed .letter {
            filter: blur(0.5px);
            transform: rotate(var(--rotation)) skew(var(--skewX), var(--skewY)) translate(var(--translateX), var(--translateY)) scaleY(var(--scaleY));
            opacity: var(--opacity);
        }
    </style>
</head>
<body>
    <button id="crushBtn">CRUSH IT!</button>
    <div id="activeWord"></div>
    <script>
        // Initialize Matter.js
        const Engine = Matter.Engine,
            Render = Matter.Render,
            World = Matter.World,
            Bodies = Matter.Bodies;

        // Create engine
        const engine = Engine.create();

        // Create renderer
        const render = Render.create({
            element: document.body,
            engine: engine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                wireframes: false,
                background: '#1a1a1a'
            }
        });

        // Create walls
        const walls = [
            Bodies.rectangle(window.innerWidth/2, window.innerHeight + 30, window.innerWidth, 60, { isStatic: true }), // bottom
            Bodies.rectangle(-30, window.innerHeight/2, 60, window.innerHeight, { isStatic: true }), // left
            Bodies.rectangle(window.innerWidth + 30, window.innerHeight/2, 60, window.innerHeight, { isStatic: true }), // right
        ];

        World.add(engine.world, walls);

        // Words to randomly choose from
        const words = ['SACRIFICE', 'DESTROY', 'OBLITERATE', 'ANNIHILATE', 'CRUSH', 'DEMOLISH', 'SHATTER', 'BREAK'];
        let currentWord = '';
        let isCrushed = false;

        function displayNewWord() {
            currentWord = words[Math.floor(Math.random() * words.length)];
            const wordContainer = document.getElementById('activeWord');
            wordContainer.innerHTML = currentWord.split('').map(char => 
                `<span class="letter">${char}</span>`
            ).join('');
            wordContainer.classList.remove('crushed');
            document.getElementById('crushBtn').textContent = 'CRUSH IT!';
            isCrushed = false;
        }

        function crushWord() {
            const wordContainer = document.getElementById('activeWord');
            wordContainer.classList.add('crushed');
            
            // Apply more dramatic random transformations to each letter
            wordContainer.querySelectorAll('.letter').forEach(letter => {
                // More extreme rotation (-20 to 20 degrees)
                const rotation = (Math.random() - 0.5) * 40;
                
                // More extreme skewing (-30 to 30 degrees)
                const skewX = (Math.random() - 0.5) * 60;
                const skewY = (Math.random() - 0.5) * 60;
                
                // Add random vertical scaling (0.7 to 1.3)
                const scaleY = 0.7 + Math.random() * 0.6;
                
                // Add random translation
                const translateX = (Math.random() - 0.5) * 15 + 'px';
                const translateY = (Math.random() - 0.5) * 15 + 'px';
                
                // Slightly randomize opacity
                const opacity = 0.85 + Math.random() * 0.15;
                
                letter.style.setProperty('--rotation', `${rotation}deg`);
                letter.style.setProperty('--skewX', `${skewX}deg`);
                letter.style.setProperty('--skewY', `${skewY}deg`);
                letter.style.setProperty('--scaleY', scaleY);
                letter.style.setProperty('--translateX', translateX);
                letter.style.setProperty('--translateY', translateY);
                letter.style.setProperty('--opacity', opacity);
            });

            document.getElementById('crushBtn').textContent = 'DROP IT!';
            isCrushed = true;
        }

        function createFallingWord() {
            const wordContainer = document.getElementById('activeWord');
            const rect = wordContainer.getBoundingClientRect();
            const color = '#FFD700';
            
            // Create a body for the word
            const body = Bodies.rectangle(
                rect.x + rect.width / 2,
                rect.y + rect.height / 2,
                rect.width,
                rect.height,
                {
                    render: {
                        fillStyle: 'transparent',
                        lineWidth: 0
                    },
                    restitution: 0.6,
                    friction: 0.1,
                    frictionAir: 0.001,
                    word: currentWord,
                    color: color,
                    crushed: true,
                    // Store the letter transformations
                    letterTransforms: Array.from(wordContainer.querySelectorAll('.letter')).map(letter => ({
                        rotation: letter.style.getPropertyValue('--rotation'),
                        skewX: letter.style.getPropertyValue('--skewX'),
                        skewY: letter.style.getPropertyValue('--skewY'),
                        scaleY: letter.style.getPropertyValue('--scaleY'),
                        translateX: letter.style.getPropertyValue('--translateX'),
                        translateY: letter.style.getPropertyValue('--translateY'),
                        opacity: letter.style.getPropertyValue('--opacity')
                    }))
                }
            );

            // Add random initial velocities
            Matter.Body.setVelocity(body, {
                x: (Math.random() - 0.5) * 5,
                y: -2
            });
            Matter.Body.setAngularVelocity(body, (Math.random() - 0.5) * 0.2);
            
            World.add(engine.world, body);
            displayNewWord();
        }

        // Custom render function for the words
        render.options.wireframes = false;
        Matter.Events.on(render, 'afterRender', function() {
            const context = render.context;
            const bodies = Matter.Composite.allBodies(engine.world);
            
            context.font = 'bold 48px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            bodies.forEach(function(body) {
                if (body.word) {
                    const { x, y } = body.position;
                    const angle = body.angle;
                    
                    context.save();
                    context.translate(x, y);
                    context.rotate(angle);
                    
                    if (body.crushed) {
                        context.scale(0.4, 1);
                        
                        // Draw each letter with its individual transformation
                        const letterWidth = context.measureText('M').width; // Use 'M' as reference
                        const startX = -(body.word.length * letterWidth) / 2;
                        
                        body.word.split('').forEach((char, i) => {
                            const transform = body.letterTransforms[i];
                            context.save();
                            
                            // Apply individual letter transformations
                            const x = startX + (i * letterWidth);
                            context.translate(x, 0);
                            
                            // Parse the stored transformations
                            const rotation = parseFloat(transform.rotation);
                            const skewX = parseFloat(transform.skewX);
                            const skewY = parseFloat(transform.skewY);
                            const scaleY = parseFloat(transform.scaleY);
                            const translateX = parseFloat(transform.translateX);
                            const translateY = parseFloat(transform.translateY);
                            const opacity = parseFloat(transform.opacity);
                            
                            // Apply transformations
                            context.rotate(rotation * Math.PI / 180);
                            context.transform(1, Math.tan(skewY * Math.PI / 180), Math.tan(skewX * Math.PI / 180), 1, 0, 0);
                            context.scale(1, scaleY);
                            context.translate(translateX, translateY);
                            
                            context.fillStyle = `rgba(255, 215, 0, ${opacity})`;
                            context.fillText(char, 0, 0);
                            
                            context.restore();
                        });
                    } else {
                        context.fillStyle = body.color;
                        context.fillText(body.word, 0, 0);
                    }
                    
                    context.restore();
                }
            });
        });

        // Button click handler
        document.getElementById('crushBtn').addEventListener('click', function() {
            if (!isCrushed) {
                crushWord();
            } else {
                createFallingWord();
            }
        });

        // Initial setup
        displayNewWord();

        // Run the engine and renderer
        Engine.run(engine);
        Render.run(render);

        // Handle window resize
        window.addEventListener('resize', () => {
            render.canvas.width = window.innerWidth;
            render.canvas.height = window.innerHeight;
            walls[0].position.x = window.innerWidth/2;
            walls[1].position.y = window.innerHeight/2;
            walls[2].position.x = window.innerWidth + 30;
            walls[2].position.y = window.innerHeight/2;
        });
    </script>
</body>
</html>
